---
title: "TSS Reference Benchmarks"
author: "S. Berzins, A. Thompson"
date: "2025-10-21"
output: html_document
---

#### **PREFACE:** This script explores the creation of a site-specific reference benchmark for total suspended solids (TSS) for ESM 566 Fall Environmental Statistics final project.

# **1 - LOAD PACKAGES**

```{r warning=TRUE}
library(tidyverse)
library(readxl)
library(writexl)
library(randomForest)
```

# **2 - IMPORT DATA**

## STATIONS/TSS - *FROM WATER CHEMISTRY BENCHMARKS SCRIPT*

```{r}
tss <- read_excel("tss_2025-11-05.xlsx") #output file from ref benchmarks script
tss <- tss %>% 
  select(c(MLocID, StationDes, Lat_DD, Long_DD, Result_Numeric_mod, L3Eco, EcoRegion3, EcoRegion4, HUC8, ReferenceSite, COMID)) %>% 
  mutate(TSS = Result_Numeric_mod) %>% 
  select(-Result_Numeric_mod)

comids <- tss %>% select(COMID) #get just the COMIDs for next step
```

## WATERSHED PREDICTOR VARIABLES - *FROM EPA STREAMCAT*

#### Learn about StreamCat predictors here: <https://www.epa.gov/national-aquatic-resource-surveys/streamcat-metrics-and-definitions>

#### Make table of StreamCat metadata and clean up in Excel

```{r}
#supposedly best source for query-able metric names
#partable <- StreamCatTools::sc_get_metric_names()

#name mismatch error message suggests consulting this list
#scpar <- StreamCatTools::sc_get_params(param = 'metric_names') 

#save intermediate file initially; switch to Teams to clean up, then no need to run these first steps
#write_xlsx(partable, path = "C:/Users/athomps/OneDrive - Oregon/Desktop/partable.xlsx") 

kitty <- read_excel("~/BioMonORDEQ/Benchmarks/Water Chemistry/TSS Class Project/StreamCatMetrics_new.xlsx") #final metrics table

#keepers <- subset(kitty, kitty$`Use?`=='y') #keep only parameters of interest
#mets <- keepers[,5] #make data frame of keeper metric names capable of querying data

# FOR TESTING INDIVIDUAL METRICS/COMIDS (e.g., to ensure names match)
#test <- StreamCatTools::sc_get_data(comid = '23910659', metric = 'precipminusevt', showAreaSqKm = FALSE, aoi='watershed')
```

#### Run function to query all StreamCat data for selected COMIDs by subcategory

```{r}
# full data pulls use aoi='catchment,watershed,other')) 
# generating Spearman ranks use aoi='watershed')). Run separate line for aoi='other' since they don't pull unless on their own


# FUNCTION - START +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
get_streamcat <- function(comids, type = c("Agriculture","Climate","Dams","Flow","IWI","Land Cover","Lithology","Mining_Toxics","Roads",
                                           "Urban","Wildfire","Others")){
type <- match.arg(type)
#comids_split <- split(comids, ceiling(seq_along(comids)/750)) #removed b/c doesn't seem to be doing anything - wrong data class??

if(type == "Agriculture"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'canaldens,pctagdrainage,pctagslphigh2001,pctagslpmid2001,pestic1997,sw_flux,waterinput,wdrw_LD,pctcrop2001,pcthay2001,cbnf,fert,manure,nani,nsurp,agkffact',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed')) 
  }

if(type == "Climate"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'precip2008,precip8110,precip9120,tmax8110,tmax9120,tmean2008,tmean8110,tmean9120,tmin8110,tmin9120,inorgnwetdep2008,nh42008,no32008,sn2008,precipminusevt,wetindex', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Dams"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'damdens,damnidstor,damnrmstor,NABD_Dens,NABD_NIDStor,NABD_NrmStor', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Flow"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bfi,elev,runoff', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "IWI"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'chem,conn,habt,hyd,sed,temp', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Land Cover"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctbl2001,pctconif2001,pctdecid2001,pctgrs2001,pcthbwet2001,pctice2001,pctmxfst2001,pctow2001,pctshrb2001,pcturbhi2001,pcturblo2001,pcturbmd2001,pcturbop2001,pctwdwet2001,pctfrstloss2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Lithology"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'al2o3,cao,compstrgth,fe2o3,hydrlcond,k2o,mgo,na2o,p2o5,pctalkintruvol,pctalluvcoast,pctcarbresid,pctcoastcrs,pctcolluvsed,pcteolcrs,pcteolfine,pctextruvol,pctglaclakecrs,pctglaclakefine,pctglactilclay,pctglactilcrs,pctglactilloam,pcthydric,pctnoncarbresid,pctsallake,pctsilicic,pctwater,rockn,s,sio2,clay,kffact,om,perm,Rckdep,rckdep,sand,wtdep,n',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Mining_Toxics"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'coalminedens,minedens,superfunddens,tridens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Roads"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'rdcrs,rdcrsslpwtd,rddens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Urban"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'huden2010,npdesdens,popden2010,septic,wwtpalldens,wwtpmajordens,wwtpminordens,pctimp2001,pctimpslphigh2001,pctimpslpmid2001,pctnonagintrodmanagveg', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Wildfire"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctfire2002,pctburnarea2002,pcthighsev2002,pctincvegresp2002,pctlowsev2002,pctmodsev2002,pctnonprocmask2002,pctundsev2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Others"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bankfulldepth,bankfullwidth,ici,iwi,mast2008,msst2008,mwst2008,thalwagdepth,wettedwidth', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='other')) 
  }

names(streamcat) <- base::toupper(names(streamcat))
return(streamcat)
}
# FUNCTION - END  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```

#### Pull StreamCat data by subcategory and merge

```{r}
# PULL DATA BY SUBCATEGORY/TYPE
ag <- get_streamcat(comids = comids, type = "Agriculture")
clim <- get_streamcat(comids = comids, type = "Climate")
dams <- get_streamcat(comids = comids, type = "Dams")
flow <- get_streamcat(comids = comids, type = "Flow")
iwi <- get_streamcat(comids = comids, type = "IWI") #except prg_bmmi0809 b/c it crashes API
cover <- get_streamcat(comids = comids, type = "Land Cover")
litho <- get_streamcat(comids = comids, type = "Lithology") 
mintox <- get_streamcat(comids = comids, type = "Mining_Toxics")
roads <- get_streamcat(comids = comids, type = "Roads")
urb <- get_streamcat(comids = comids, type = "Urban")
fire <- get_streamcat(comids = comids, type = "Wildfire")
other <- get_streamcat(comids = comids, type = "Others")

# MERGE INTO ONE TABLE
meow <- list(ag, clim, dams, flow, iwi, cover, litho, mintox, roads, urb, fire, other)
meow <- meow %>% reduce(full_join, by='COMID')

# IDENTIFY WHICH COMID(S) DIDN'T YIELD STREAMCAT RESULTS AND INVESTIGATE (FIX IN STATIONS DB BEFORE PROCEEDING)
# kcomids <- meow %>% select(COMID)
# nomatch <- comids[!comids$COMID %in% kcomids$COMID, ] #make data frame showing which COMIDs aren't pulling StreamCat data
# #nomatch.c <- subset(tss, tss$COMID == "23764745" | tss$COMID == "24516234" | tss$COMID == "23815386") #change COMIDs as needed
# rm(list = c('nomatch', 'nomatch.c', 'kcomids')) #clean up environment

# EXPLORE VARIANCE FOR EACH METRIC TO GUIDE WHICH TO KEEP
# meow.sca <- as.data.frame(scale(meow[,-10])) #not used
# 
# var <- meow %>%
#   select(where(is.numeric)) %>%
#   pivot_longer(cols = everything()) %>%
#   group_by(name) %>%
#   summarise(var_value = var(value))
```

#### Make Spearman correlation matrix to identify covaried parameters

```{r, warning=FALSE}
# FULL CORRELATION MATRIX - ALL VARIABLES
spear <- cor(meow, method = "spearman", use = "pairwise.complete.obs")
spear <- as.data.frame(spear)
spear.rows <- tibble::rownames_to_column(spear)

#export once, then clean up in Excel
#write_xlsx(spear.rows, path = "C:/Users/athomps/Oregon/DEQ - Biomonitoring is Fun! - General/Env't Stats Class Project 2025/StreamCat/Spearmans.xlsx")

# CONDENSED CORRELATION MATRIX - ONLY VARIABLES >|0.8|
matrix <- spear.rows %>%  
  gather(-rowname, key = "colname", value = "cor") %>% 
  filter(abs(cor) > 0.8)

#export once, then clean up in Excel
#write_xlsx(matrix, path = "C:/Users/athomps/Oregon/DEQ - Biomonitoring is Fun! - General/Env't Stats Class Project 2025/StreamCat/Spearmans2_rerun.xlsx")

rm(list=c('ag', 'clim', 'dams', 'flow','iwi', 'cover', 'litho', 'mintox', 'roads', 'urb', 'fire', 'other', 'spear', 'spear.rows'))
```

## EXPLORE CO-VARIED PARAMETERS AND SELECT WHICH WE WANT TO RETAIN FOR MODELLING PURPOSES - SB, SH, AT did this together in Excel.  See https://stateoforegon.sharepoint.com/:x:/r/sites/BiomonitoringisFun/Shared%20Documents/General/Env%27t%20Stats%20Class%20Project%202025/StreamCat/Spearmans2.xlsx?d=wc5d82026542a417589be75842d6fafe3&csf=1&web=1&e=dhYR5Q for decisions, and https://stateoforegon.sharepoint.com/:x:/r/sites/BiomonitoringisFun/Shared%20Documents/General/Env%27t%20Stats%20Class%20Project%202025/StreamCat/Spearmans2.xlsx?d=wc5d82026542a417589be75842d6fafe3&csf=1&web=1&e=dhYR5Q for full list of metric names.

## PULL STREAMCAT AGAIN, BUT ONLY FOR PARAMETERS OF INTEREST

```{r}
# FUNCTION - START +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
get_streamcat <- function(comids, type = c("Agriculture2","Climate2","Dams2","Flow2","IWI2","Land Cover2","Lithology2","Mining_Toxics2","Roads2",
                                           "Urban2","Wildfire2","Others2")){
type <- match.arg(type)
#comids_split <- split(comids, ceiling(seq_along(comids)/750)) #removed b/c doesn't seem to be doing anything - wrong data class??

if(type == "Agriculture2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'canaldens,pctagdrainage,pctagslpmid2001,pestic1997,wdrw_LD,pctcrop2001,sw_flux',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed')) 
  }

if(type == "Climate2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'precip9120,wetindex', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Dams2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'damdens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Flow2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bfi,elev',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "IWI2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'chem,conn,hyd',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Land Cover2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctbl2001,pctconif2001,pctgrs2001,pcthbwet2001,pctice2001,pctmxfst2001,pctow2001,pctshrb2001,pcturbhi2001,pcturbmd2001,pcturbop2001,pctwdwet2001,pctfrstloss2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Lithology2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'compstrgth,fe2o3,hydrlcond,na2o,pctalkintruvol,pctalluvcoast,pctcarbresid,pctcoastcrs,pctcolluvsed,pcteolcrs,pcteolfine,pctextruvol,pctglaclakecrs,pctglaclakefine,pctglactilclay,pctglactilcrs,pctglactilloam,pcthydric,pctnoncarbresid,pctsallake,pctsilicic,pctwater,rockn,s,clay,kffact,om,Rckdep,rckdep,sand,wtdep,n',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Mining_Toxics2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'coalminedens,minedens,superfunddens,tridens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Roads2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'rdcrs,rdcrsslpwtd,rddens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Urban2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'npdesdens,popden2010,septic,wwtpalldens,wwtpmajordens,pctimp2001,pctnonagintrodmanagveg', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Wildfire2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctfire2002,pctincvegresp2002,pctnonprocmask2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Others2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bankfullwidth,iwi,msst2008',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='other')) 
  }

names(streamcat) <- base::toupper(names(streamcat))
return(streamcat)
}
# FUNCTION - END  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```

## PULL STREAMCAT AGAIN BUT ONLY FOR PARAMETERS OF INTEREST

```{r}
# PULL DATA BY SUBCATEGORY/TYPE
ag2 <- get_streamcat(comids = comids, type = "Agriculture2")
clim2 <- get_streamcat(comids = comids, type = "Climate2")
dams2 <- get_streamcat(comids = comids, type = "Dams2")
flow2 <- get_streamcat(comids = comids, type = "Flow2")
iwi2 <- get_streamcat(comids = comids, type = "IWI2") #except prg_bmmi0809 b/c it crashes API
cover2 <- get_streamcat(comids = comids, type = "Land Cover2")
litho2 <- get_streamcat(comids = comids, type = "Lithology2") 
mintox2 <- get_streamcat(comids = comids, type = "Mining_Toxics2")
roads2 <- get_streamcat(comids = comids, type = "Roads2")
urb2 <- get_streamcat(comids = comids, type = "Urban2")
fire2 <- get_streamcat(comids = comids, type = "Wildfire2")
other2 <- get_streamcat(comids = comids, type = "Others2")

# MERGE INTO ONE TABLE
meow2 <- list(ag2, clim2, dams2, flow2, iwi2, cover2, litho2, mintox2, roads2, urb2, fire2) # Removed other2 to remove IWI metrics.  11/5/25.
meow2 <- meow2 %>% reduce(full_join, by='COMID')

# FINAL CHECK FOR CORRELATED VARIABLES
spear2 <- cor(meow2, method = "spearman", use = "pairwise.complete.obs")
spear2 <- as.data.frame(spear2)
spear.rows2 <- tibble::rownames_to_column(spear2)

matrix2 <- spear.rows2 %>%  
  gather(-rowname, key = "colname", value = "cor") %>% 
  filter(abs(cor) > 0.8)

# REMOVE METRICS FOR UNWANTED REPRESENTATIVE COMIDS FOR SITES ON HIGH RES NHD LAYER
scmets <- subset(meow2, meow2$COMID != '23774647' & meow2$COMID != '23877125' & meow2$COMID != '23810652')

# CLEAN UP ENVIRONMENT
rm(list=c('ag2','clim2','cover2','dams2','fire2','flow2','iwi2','litho2','mintox2','other2','roads2','urb2','meow2', 'spear.rows2', 'spear2'))

# GROUP PREDICTORS BY HUMAN VS NATURAL
human.mets <- kitty %>% 
  filter(Category == "Anthropogenic" & kitty$`Use?` == 'y') %>% 
  select(Metric_Query)

human.mets <- toupper(human.mets$Metric_Query)

natural.mets <- kitty %>% 
  filter(Category == "Natural" & kitty$`Use?` == 'y') %>% 
  select(Metric_Query)

natural.mets <- toupper(natural.mets$Metric_Query)

# Select out scmets by human and natural.
# Ending in WS only
scmetsws <- scmets %>% 
    select(ends_with("ws")) 
# Remove 'WS' suffix so can match to metric names in 'kitty' table
colnames(scmetsws) <- substr(colnames(scmetsws), 1, nchar(colnames(scmetsws))-2)

# Subset only column names that are in human or natural mets
scmetws_human <- scmetsws[ , names(scmetsws) %in% human.mets] # 29 variables
scmetws_natural <- scmetsws[ , names(scmetsws) %in% natural.mets] # 47 variables

# Add 'WS' suffix back in
colnames(scmetws_human) <- paste0(colnames(scmetws_human), "WS")
colnames(scmetws_natural) <- paste0(colnames(scmetws_natural), "WS")
  
# Do the same thing for metrics not ending in 'WS'
scmetsnows <- scmets %>% 
    select(!ends_with("ws"))

scmet_human <- scmetsnows[ , names(scmetsnows) %in% human.mets] # 1 variable
scmet_natural <- scmetsnows[ , names(scmetsnows) %in% natural.mets] # 2 variables

sc_human <- cbind(scmetws_human, scmet_human) # 30 variables
sc_natural <- cbind(scmetws_natural, scmet_natural) # 49 variables (Total of 79, matches scmets)

# SYB figure out how to keep COMID as a column.
```

## KERNEL DENSITY PLOTS - decide if helpful

```{r}
# RANDOM FORESTS
sapply(scmets, function(x) sum(is.na(x))) #find out which columns have NAs

scmets$BANKFULLWIDTH <- na.roughfix(scmets$BANKFULLWIDTH) #perform na.roughfix on all metrics with at least 1 NA; create extra code rows as needed
scmets$SW_FLUXWS <- na.roughfix(scmets$SW_FLUXWS)

tss.sc <- inner_join(tss, scmets, by = "COMID") #merge TSS AWQMS data pull with desired StreamCat metrics

# SUBSET DATA
tss.cal <- subset(tss.sc, tss.sc$cal_val == "CAL") #subset calibration dataset
tss.val <- subset(tss.sc, tss.sc$cal_val == "VAL") #subset validation dataset
tss.ref <- subset(tss.sc, tss.sc$ReferenceSite == "REFERENCE") #subset reference only dataset

# FULL MODEL
set.seed(42)

rf.full <- randomForest(y = tss.cal$Result_Numeric_mod, x = tss.cal[52:130], importance = TRUE,  keep.forest = TRUE, ntree = 500) #run random forest model on all predictors for 500 trees, calibration dataset
print(rf.full)

varImpPlot(rf.full, type = 1, n.var = 20) #variable importance plot

# REDUCED MODEL
rf.red <- randomForest(Result_Numeric_mod ~ CHEMWS+HYDWS+RDCRSWS+PESTIC1997WS+CONNWS+PCTCROP2001WS+WETINDEXWS+PCTSHRB2001WS+ELEVWS+WDRW_LDWS+IWI, data = tss.cal, importance = TRUE,  keep.forest = TRUE, ntree = 500) #only w/ predictors >4% MSE
print(rf.red)

varImpPlot(rf.red, type = 1) #variable importance plot

importance(rf.red)


# RUN REDUCED MODEL ON VALIDATION DATASET


# REFERENCE ONLY
rf.ref <- randomForest(y = tss.ref$Result_Numeric_mod, x = tss.ref[52:130], importance = TRUE,  keep.forest = TRUE, ntree = 500) #run random forest model on all predictors for 500 trees, calibration dataset
print(rf.ref)

varImpPlot(rf.ref, type = 1)


```



```{r}
# EXPLORE IF REMOVED COMIDS WERE OUTLIERS 
removed <- subset(meow2, meow2$COMID == '23774647' | meow2$COMID == '23877125' | meow2$COMID == '23810652')

# MESSING AROUND WITH KERNEL DENSITY PLOTS TO SUMMARIZE METRICS
colnames(scmets)
attach(scmets)

hist(ELEVWS, breaks=100)
hist(BFIWS, breaks=100)
hist(CANALDENSWS, breaks=100)
hist(CLAYWS, breaks=100)
hist(KFFACTWS, breaks=100)

density(CLAYWS)
#-----------
library(KernSmooth)

bkde(CLAYWS)
summary(CLAYWS)

clay.ws<-CLAYWS[!is.na(CLAYWS)]
summary(clay.ws)

plot(bkde(clay.ws))

plot(density(clay.ws))
rug(jitter(clay.ws))
#-----------
kern <- scmets %>%
  select(CLAYWS, BFIWS, ELEVWS, KFFACTWS, IWI, RDDENSWS)

kern %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
  facet_wrap(~ key, scales = "free") +
  geom_density() +
  geom_rug() 
```


# **3 - BUILD MODEL**
## ASSESS NAs AND SUBSET DATA

```{r}
sapply(scmets, function(x) sum(is.na(x))) #find out which columns have NAs

scmets$BANKFULLWIDTH <- na.roughfix(scmets$BANKFULLWIDTH) #perform na.roughfix on all metrics with at least 1 NA; create extra code rows as needed
scmets$SW_FLUXWS <- na.roughfix(scmets$SW_FLUXWS)

tss.sc <- inner_join(tss, scmets, by = "COMID") #merge TSS AWQMS data pull with desired StreamCat metrics

# SUBSET DATA
tss.cal <- subset(tss.sc, tss.sc$cal_val == "CAL") #subset calibration dataset
tss.val <- subset(tss.sc, tss.sc$cal_val == "VAL") #subset validation dataset
tss.ref <- subset(tss.sc, tss.sc$ReferenceSite == "REFERENCE") #subset reference only dataset
```

## RANDOM FORESTS

#### FULL MODEL

```{r}
# FULL MODEL
set.seed(42)

rf.full <- randomForest(y = tss.cal$Result_Numeric_mod, x = tss.cal[52:130], importance = TRUE,  keep.forest = TRUE, ntree = 500) #run random forest model on all predictors
print(rf.full)

varImpPlot(rf.full, type = 1, n.var = 20) #variable importance plot
library(vip)
vip(rf.full, aesthetics = list(color = "blue", fill = "blue")) #another plot

importance(rf.full)

# PARTIAL DEPENDENCE PLOTS - SINGLE ONLY, NEED TO INCORPORATE FOR LOOP FOR ALL VBLS
rf.full <- randomForest(Result_Numeric_mod ~ ., data = tss.cal.test)
partialPlot(rf.full, as.data.frame(tss.cal.test), ELEVWS, ylab = "Predicted TSS")


# MODEL'S PREDICTION ERROR
pred.rf <- predict(rf.full, newdata = tss.val.test)
plot(pred.rf ~ tss.val.test$Result_Numeric_mod, xlab="Observed TSS", ylab="Predicted TSS")
abline(a=0,b=1)
(rmse<-sqrt(sum((pred.rf - tss.val.test$Result_Numeric_mod)^2)/length(tss.val.test$Result_Numeric_mod)))#prediction error
```

#### REDUCED MODEL

```{r}
# REDUCED MODEL
set.seed(42)

rf.red <- randomForest(Result_Numeric_mod ~ CHEMWS+HYDWS+RDCRSWS+PESTIC1997WS+CONNWS+PCTCROP2001WS+WETINDEXWS+PCTSHRB2001WS+ELEVWS+WDRW_LDWS+IWI, data = tss.cal, importance = TRUE,  keep.forest = TRUE, ntree = 500) #only w/ predictors >4% MSE
print(rf.red)

varImpPlot(rf.red, type = 1) #variable importance plot
importance(rf.red)
```


#### TEST FULL MODEL WITH VAL DATA
```{r}
# REMAKE CAL RF WITHOUT EXTRA AWQMS COLUMNS 
rf.test <- randomForest(Result_Numeric_mod ~., data = tss.cal.test)


# CONFUSION MATRIX
library(caret)
tss.val$RFtss <- predict(rf.test, tss.val.test) #model prediction on 'VAL' dataset
RFtss <- tss.val %>% select(RFtss, COMID)
RFval <- tss.val %>% select(Result_Numeric_mod, COMID)

cm <- inner_join(RFtss, RFval, by = "COMID")
confusionMatrix(data = as.factor(cm$RFtss), reference = as.factor(cm$Result_Numeric_mod)) #NOT WORKING YET

plot(cm$RFtss, cm$Result_Numeric_mod)
```











#### REFERENCE ONLY MODEL

```{r}
# REFERENCE ONLY
rf.ref <- randomForest(y = tss.ref$Result_Numeric_mod, x = tss.ref[52:130], importance = TRUE,  keep.forest = TRUE, ntree = 500) #run random forest model on all predictors
print(rf.ref)

varImpPlot(rf.ref, type = 1)
importance(rf.ref)
```



#### MULTIPLE LINEAR REGRESSION 

```{r}
# LINEAR REGRESSION MODEL FIT
lr.f <- lm(Result_Numeric_mod ~ ., data = tss.cal.test)
#lr.r <- lm(Result_Numeric_mod ~ PCTAGSLPMID2001WS+PCTAGSLPMID2001WS+WETINDEXWS+PRECIP9120WS+CHEMWS+PCTBL2001WS+PCTICE2001WS+
           PCTURBMD2001WS+HYDRLCONDWS+SANDWS+MINEDENSWS+SUPERFUNDDENSWS+RDCRSSLPWTDWS+RDCRSWS+WWTPALLDENSWS, data = tss.cal.test) #subset significant predictors
lr.r2 <- lm(Result_Numeric_mod ~ CONNWS+HYDWS+IWI+PCTSHRB2001WS+PESTIC1997WS+PCTURBMD2001WS+PCTAGSLPMID2001WS+PCTGRS2001WS+PRECIP9120WS+PCTCONIF2001WS, data = tss.cal.test) #subset significant predictors


summary(lr.f)
summary(lr.r)
summary(lr.r2)

par(mfrow=c(2,2))
plot(lr.f)




t <- tss.cal.test %>% select(Result_Numeric_mod,PCTAGSLPMID2001WS,PCTAGSLPMID2001WS,WETINDEXWS,PRECIP9120WS,CHEMWS,PCTBL2001WS,PCTICE2001WS,
           PCTURBMD2001WS,HYDRLCONDWS,SANDWS,MINEDENSWS,SUPERFUNDDENSWS,RDCRSSLPWTDWS,RDCRSWS,WWTPALLDENSWS) #subset significant predictors
#sapply(t, function(x) sum(is.na(x))) #find out which columns have NAs
#source("D:/ESM 566/3_Worksheets/cor.matrix.r")
#cor.matrix(t)
```


#### REGRESSION TREES

```{r}
# REGRESSION TREES EXPERIMENTATION
tss.r <- tss.sc %>% select(Result_Numeric_mod, COMID, cal_val)
tss.test <- inner_join(tss.r, scmets, by = "COMID") 

tss.cal.test <- subset(tss.test, tss.test$cal_val == "CAL")
tss.cal.test <- tss.cal.test[,-c(2:3)]

tss.val.test <- subset(tss.test, tss.test$cal_val == "VAL")
tss.val.test <- tss.val.test[,-c(2:3)]

library(rpart)
library(rpart.plot)

# FULL MODEL
rt <- rpart(Result_Numeric_mod ~ ., data = tss.cal.test)
plot(rt)
text(rt, use.n = TRUE)

names(rt)
print(rt)
summary(rt)

prp(rt, #plot the tree model
    faclen=0,#use full names for factor labels
    extra=1)#display number of obs. for each terminal node
#-----------------------------------------------------------------------------------------------
library(vip)# for variable importance plots. you may need to install it first
vip(rt, aesthetics = list(color = "blue", fill = "blue")) #variable importance plot
plotcp(rt) #model cross-validation




# REDUCED MODEL
rt.r <- rpart(Result_Numeric_mod ~ CONNWS+HYDWS+IWI+PCTSHRB2001WS+PESTIC1997WS+PCTURBMD2001WS+PCTAGSLPMID2001WS+PCTGRS2001WS+PRECIP9120WS+PCTCONIF2001WS, data = tss.cal.test)
plot(rt.r)
text(rt.r, use.n = TRUE)

summary(rt.r)

prp(rt.r, #plot the tree model
    faclen=0,#use full names for factor labels
    extra=1)#display number of obs. for each terminal node
#-----------------------------------------------------------------------------------------------
vip(rt.r, aesthetics = list(color = "blue", fill = "blue")) #variable importance plot
plotcp(rt.r) #model cross-validation




# TEST REDUCED MODEL ON VAL DATASET
p <- predict(rt.r, newdata = tss.val) #OLS model prediction
plot(p ~ tss.val$Result_Numeric_mod, ylab = "Predicted TSS", xlab = "Observed TSS", ylim=c(0,30))
abline(a = 0, b = 1) #1:1 line
sqrt(sum((p-tss.val$Result_Numeric_mod)^2)/length(tss.val$Result_Numeric_mod)) #predictive error

# Test if the final reduced model is statistically different from the full model
anova(rt, rt.r) #error  - no applicable method for "rpart"
```








=======
```


>>>>>>> aee75da575663b3534d8fae084b04755d64cda5f
# TO DELETE

```{r}
#tss.r <- tss.sc %>% select(Result_Numeric_mod)
#tss.r <- tss.sc %>% select(Result_Numeric_mod, COMID, cal_val)
r <- randomForest(Result_Numeric_mod ~ CLAYWS + BFIWS + ELEVWS + KFFACTWS + IWI + RDDENSWS, data = tss.sc, na.action = na.exclude)
print(r)

t <- tss.sc[!is.na(tss.sc$BANKFULLWIDTH),]

new_df <- df[!is.na(df)]
  
tss.sc$BANKFULLWIDTH <- na.roughfix(tss.sc$BANKFULLWIDTH) 

missing <- rownames(scmets)[rowSums(is.na(scmets))]
missing <- sum(is.na(scmets))



tss.sc <- left_join(tss, scmets, by = "COMID")
#tss.r <- tss.sc %>% select(Result_Numeric_mod)
r <- randomForest(Result_Numeric_mod ~ CLAYWS + BFIWS + ELEVWS + KFFACTWS + IWI + RDDENSWS, data = tss.sc, na.action = na.exclude)
print(r)
```

