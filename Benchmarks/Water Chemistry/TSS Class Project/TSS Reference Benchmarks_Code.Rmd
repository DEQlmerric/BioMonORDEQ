---
title: "TSS Reference Benchmarks"
author: "S. Berzins, A. Thompson"
date: "2025-10-21"
output: html_document
---

#### **PREFACE:** This script explores the creation of a site-specific reference benchmark for total suspended solids (TSS) for ESM 566 Fall Environmental Statistics final project.

# **1 - LOAD PACKAGES**

```{r warning=FALSE}
library(tidyverse)
library(StreamCatTools) 
library(readxl)
library(writexl)
library(randomForest)
library(vip)
library(caret)
library(rpart)
library(rpart.plot)
library(ORDEQBioassessment)
library(reprtree)  # Try devtools::install_github('araastat/reprtree')
```

# **2 - IMPORT DATA**

## STATIONS/TSS - *FROM WATER CHEMISTRY BENCHMARKS SCRIPT*

```{r}
tss <- read_excel("TSS_2025-11-06.xlsx") #output file from ref benchmarks script

comids <- tss %>% select(COMID) #get just the COMIDs for next step
```

## WATERSHED PREDICTOR VARIABLES - *FROM EPA STREAMCAT*

#### Learn about StreamCat predictors: <https://www.epa.gov/national-aquatic-resource-surveys/streamcat-metrics-and-definitions>

#### View StreamCat updates: <https://www.epa.gov/national-aquatic-resource-surveys/streamcat-updates>

#### Make table of StreamCat metadata and clean up in Excel

```{r}
#supposedly best source for query-able metric names
#partable <- StreamCatTools::sc_get_metric_names()

#name mismatch error message suggests consulting this list
#scpar <- StreamCatTools::sc_get_params(param = 'metric_names') 

#save intermediate file initially; switch to Teams to clean up, then no need to run these first steps
#write_xlsx(partable, path = "C:/Users/athomps/OneDrive - Oregon/Desktop/partable.xlsx") 

kitty <- read_excel("~/BioMonORDEQ/Benchmarks/Water Chemistry/TSS Class Project/StreamCatMetrics_new.xlsx") #final metrics table

#keepers <- subset(kitty, kitty$`Use?`=='y') #keep only parameters of interest
#mets <- keepers[,5] #make data frame of keeper metric names capable of querying data

# FOR TESTING INDIVIDUAL METRICS/COMIDS (e.g., to ensure names match)
#test <- StreamCatTools::sc_get_data(comid = '23910659', metric = 'precipminusevt', showAreaSqKm = FALSE, aoi='watershed')
```

#### Run function to query ALL StreamCat data for selected COMIDs by subcategory

```{r}
# full data pulls use aoi='catchment,watershed,other')) 
# generating Spearman ranks use aoi='watershed')). Run separate line for aoi='other' since they don't pull unless on their own


# FUNCTION - START +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
get_streamcat <- function(comids, type = c("Agriculture","Climate","Dams","Flow","IWI","Land Cover","Lithology","Mining_Toxics","Roads",
                                           "Urban","Wildfire","Others")){
type <- match.arg(type)
#comids_split <- split(comids, ceiling(seq_along(comids)/750)) #removed b/c doesn't seem to be doing anything - wrong data class??

if(type == "Agriculture"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'canaldens,pctagdrainage,pctagslphigh2001,pctagslpmid2001,pestic1997,sw_flux,waterinput,wdrw_LD,pctcrop2001,pcthay2001,cbnf,fert,manure,nani,nsurp,agkffact',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed')) 
  }

if(type == "Climate"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'precip2008,precip8110,precip9120,tmax8110,tmax9120,tmean2008,tmean8110,tmean9120,tmin8110,tmin9120,inorgnwetdep2008,nh42008,no32008,sn2008,precipminusevt,wetindex', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Dams"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'damdens,damnidstor,damnrmstor,NABD_Dens,NABD_NIDStor,NABD_NrmStor', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Flow"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bfi,elev,runoff', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "IWI"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'chem,conn,habt,hyd,sed,temp', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Land Cover"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctbl2001,pctconif2001,pctdecid2001,pctgrs2001,pcthbwet2001,pctice2001,pctmxfst2001,pctow2001,pctshrb2001,pcturbhi2001,pcturblo2001,pcturbmd2001,pcturbop2001,pctwdwet2001,pctfrstloss2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Lithology"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'al2o3,cao,compstrgth,fe2o3,hydrlcond,k2o,mgo,na2o,p2o5,pctalkintruvol,pctalluvcoast,pctcarbresid,pctcoastcrs,pctcolluvsed,pcteolcrs,pcteolfine,pctextruvol,pctglaclakecrs,pctglaclakefine,pctglactilclay,pctglactilcrs,pctglactilloam,pcthydric,pctnoncarbresid,pctsallake,pctsilicic,pctwater,rockn,s,sio2,clay,kffact,om,perm,Rckdep,rckdep,sand,wtdep,n',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Mining_Toxics"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'coalminedens,minedens,superfunddens,tridens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Roads"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'rdcrs,rdcrsslpwtd,rddens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Urban"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'huden2010,npdesdens,popden2010,septic,wwtpalldens,wwtpmajordens,wwtpminordens,pctimp2001,pctimpslphigh2001,pctimpslpmid2001,pctnonagintrodmanagveg', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Wildfire"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctfire2002,pctburnarea2002,pcthighsev2002,pctincvegresp2002,pctlowsev2002,pctmodsev2002,pctnonprocmask2002,pctundsev2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Others"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bankfulldepth,bankfullwidth,ici,iwi,mast2008,msst2008,mwst2008,thalwagdepth,wettedwidth', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='other')) 
  }

names(streamcat) <- base::toupper(names(streamcat))
return(streamcat)
}
# FUNCTION - END  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```

#### Pull ALL StreamCat data by subcategory and merge

```{r}
# PULL DATA BY SUBCATEGORY/TYPE
ag <- get_streamcat(comids = comids, type = "Agriculture")
clim <- get_streamcat(comids = comids, type = "Climate")
dams <- get_streamcat(comids = comids, type = "Dams")
flow <- get_streamcat(comids = comids, type = "Flow")
iwi <- get_streamcat(comids = comids, type = "IWI") #except prg_bmmi0809 b/c it crashes API
cover <- get_streamcat(comids = comids, type = "Land Cover")
litho <- get_streamcat(comids = comids, type = "Lithology") 
mintox <- get_streamcat(comids = comids, type = "Mining_Toxics")
roads <- get_streamcat(comids = comids, type = "Roads")
urb <- get_streamcat(comids = comids, type = "Urban")
fire <- get_streamcat(comids = comids, type = "Wildfire")
other <- get_streamcat(comids = comids, type = "Others")

# MERGE INTO ONE TABLE
meow <- list(ag, clim, dams, flow, iwi, cover, litho, mintox, roads, urb, fire, other)
meow <- meow %>% reduce(full_join, by = 'COMID')

rm(list=c('ag', 'clim', 'dams', 'flow','iwi', 'cover', 'litho', 'mintox', 'roads', 'urb', 'fire', 'other'))
```

#### Add predictor variables not in StreamCat (erodible vs. resistant geology, slope, stream power)

```{r}
# ERODIBLE VS RESISTENT GEOLOGY (KEPT ERODIBLE, SINCE RESISTENT IS INVERSE OF ERODIBLE)
erod_resist_strmpow <- meow %>%
  mutate(PCT_EROD = PCTALLUVCOASTWS+PCTCARBRESIDWS+PCTCOASTCRSWS+PCTCOLLUVSEDWS+PCTEOLCRSWS+PCTEOLFINEWS+PCTGLACLAKECRSWS+PCTGLACLAKEFINEWS+PCTGLACTILCLAYWS+PCTGLACTILCRSWS+PCTGLACTILLOAMWS+PCTSALLAKEWS)  %>% # AT removed PCTNONCARBRESIDWS 11/7
  mutate(PCT_RESIST = PCTALKINTRUVOLWS+PCTEXTRUVOLWS+PCTHYDRICWS) #AT removed PCTSILICICWS 11/7

# SLOPE FROM NHD (TAKES 1-2 MIN)
erod_resist_strmpow <- ORDEQBioassessment::get_NHD_info(erod_resist_strmpow) 

# WATERSHED AREA AND STREAM POWER
erod_resist_strmpow <- erod_resist_strmpow %>% 
  mutate(STRMPOW_CAT = totdasqkm + PRECIP9120WS * slope) %>%  # WSAREASQKM from SC, instead pulling totdasqkm from get_NHD (they are the same)
  select(COMID, PCT_EROD, PCT_RESIST, STRMPOW_CAT, NHD_pSLOPE, SITE_TYPE)
```

#### Make Spearman correlation matrix to identify co-varied parameters

```{r, warning=FALSE}
# FULL CORRELATION MATRIX
spear <- cor(meow, method = "spearman", use = "pairwise.complete.obs")
spear <- as.data.frame(spear)
spear.rows <- tibble::rownames_to_column(spear)

#export once, then clean up in Excel
#write_xlsx(spear.rows, path = "C:/Users/athomps/Oregon/DEQ - Biomonitoring is Fun! - General/Env't Stats Class Project 2025/StreamCat/Spearmans_rerun.xlsx")

# CONDENSED CORRELATION MATRIX (>0.8 ONLY)
matrix <- spear.rows %>%  
  gather(-rowname, key = "colname", value = "cor") %>% 
  filter(abs(cor) > 0.8)

#export once, then clean up in Excel
#write_xlsx(matrix, path = "C:/Users/athomps/Oregon/DEQ - Biomonitoring is Fun! - General/Env't Stats Class Project 2025/StreamCat/Spearmans2_rerun.xlsx")

rm(list=c('spear', 'spear.rows'))
```

#### Explore co-varied metrics and select which we want to retain for modeling purposes (SB, SH, AT did together in Excel). See <https://stateoforegon.sharepoint.com/:x:/r/sites/BiomonitoringisFun/Shared%20Documents/General/Env%27t%20Stats%20Class%20Project%202025/StreamCat/Spearmans2.xlsx?d=wc5d82026542a417589be75842d6fafe3&csf=1&web=1&e=dhYR5Q> for decisions, and <https://stateoforegon.sharepoint.com/:x:/r/sites/BiomonitoringisFun/Shared%20Documents/General/Env%27t%20Stats%20Class%20Project%202025/StreamCat/Spearmans2.xlsx?d=wc5d82026542a417589be75842d6fafe3&csf=1&web=1&e=dhYR5Q> for full list of metric names.

#### Run StreamCat function again, but only for parameters of interest

```{r}
# FUNCTION - START +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
get_streamcat <- function(comids, type = c("Agriculture2","Climate2","Dams2","Flow2","IWI2","Land Cover2","Lithology2","Mining_Toxics2","Roads2",
                                           "Urban2","Wildfire2","Others2")){
type <- match.arg(type)
#comids_split <- split(comids, ceiling(seq_along(comids)/750)) #removed b/c doesn't seem to be doing anything - wrong data class??

if(type == "Agriculture2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'canaldens,pctagdrainage,pctagslpmid2001,pestic1997,wdrw_LD,pctcrop2001,sw_flux',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed')) 
  }

if(type == "Climate2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'precip9120,wetindex', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Dams2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'damdens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Flow2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bfi,elev',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "IWI2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'chem,conn,hyd',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Land Cover2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctbl2001,pctconif2001,pctgrs2001,pcthbwet2001,pctice2001,pctmxfst2001,pctow2001,pctshrb2001,pcturbhi2001,pcturbmd2001,pcturbop2001,pctwdwet2001,pctfrstloss2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }
# Removed pctsilicic and pctnoncarbresid since they are correlated with erodibility.
if(type == "Lithology2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'compstrgth,fe2o3,hydrlcond,na2o,pctalkintruvol,pctalluvcoast,pctcarbresid,pctcoastcrs,pctcolluvsed,pcteolcrs,pcteolfine,pctextruvol,pctglaclakecrs,pctglaclakefine,pctglactilclay,pctglactilcrs,pctglactilloam,pcthydric,pctsallake,pctwater,rockn,s,clay,kffact,om,Rckdep,rckdep,sand,wtdep,n',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Mining_Toxics2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'coalminedens,minedens,superfunddens,tridens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Roads2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'rdcrs,rdcrsslpwtd,rddens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Urban2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'npdesdens,popden2010,septic,wwtpalldens,wwtpmajordens,pctimp2001,pctnonagintrodmanagveg', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Wildfire2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctfire2002,pctincvegresp2002,pctnonprocmask2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }
# Removed iwi from Others 2 to remove IWI metrics from data pull.
if(type == "Others2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bankfullwidth,msst2008',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='other')) 
  }

names(streamcat) <- base::toupper(names(streamcat))
return(streamcat)
}
# FUNCTION - END  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```

#### Pull StreamCat data for parameters of interest

```{r}
# PULL DATA BY SUBCATEGORY/TYPE
ag2 <- get_streamcat(comids = comids, type = "Agriculture2")
clim2 <- get_streamcat(comids = comids, type = "Climate2")
dams2 <- get_streamcat(comids = comids, type = "Dams2")
flow2 <- get_streamcat(comids = comids, type = "Flow2")
#iwi2 <- get_streamcat(comids = comids, type = "IWI2") #except prg_bmmi0809 b/c it crashes API
cover2 <- get_streamcat(comids = comids, type = "Land Cover2")
litho2 <- get_streamcat(comids = comids, type = "Lithology2") 
mintox2 <- get_streamcat(comids = comids, type = "Mining_Toxics2")
roads2 <- get_streamcat(comids = comids, type = "Roads2")
urb2 <- get_streamcat(comids = comids, type = "Urban2")
fire2 <- get_streamcat(comids = comids, type = "Wildfire2")
other2 <- get_streamcat(comids = comids, type = "Others2")

# MERGE STREAMCAT DATA PULL
meow2 <- list(ag2, clim2, dams2, flow2, cover2, litho2, mintox2, roads2, urb2, fire2, other2) # Removed iwi2 to remove IWI metrics.  11/5/25.
meow2 <- meow2 %>% reduce(full_join, by='COMID')

# CLEAN UP ENVIRONMENT
rm(list=c('ag2','clim2','cover2','dams2','fire2','flow2','litho2','mintox2','other2','roads2','urb2'))
```

#### Merge desired StreamCat metrics with additional predictors

```{r}
# JOIN WITH OTHER PARAMETERS NOT FROM SC (erodible vs. resistant, slope, stream power)
scmets <- inner_join(meow2, erod_resist_strmpow, by='COMID')

# REMOVE METRICS FOR UNWANTED REPRESENTATIVE COMIDS FOR SITES ON HIGH RES NHD LAYER
scmets <- subset(scmets, meow2$COMID != '23774647' & meow2$COMID != '23877125' & meow2$COMID != '23810652')
```

#### Pefrorm final correlation check

```{r, warning=FALSE}
# FULL CORRELATION MATRIX
spear2 <- cor(meow2, method = "spearman", use = "pairwise.complete.obs")
spear2 <- as.data.frame(spear2)
spear.rows2 <- tibble::rownames_to_column(spear2)

# CONDENSED CORRELATION MATRIX (>0.8 ONLY)
matrix2 <- spear.rows2 %>%  
  gather(-rowname, key = "colname", value = "cor") %>% 
  filter(abs(cor) > 0.8)

# ***CONTINUE ONCE NO CORRELATED VARIABLES REMAIN***


# Will remove PCT_SILICICWS and PCT_NONCARBRESIDWS since the are correlated with PCT_EROD >0.8 -- AT: I DID THIS ABOVE SO EROD_RES CODE WOULD RUN
```


# **3 - PREPARE DATA FOR MODELS**

## HANDLE NA VALUES AND MERGE PREDICTORS WITH TSS DATA 

```{r}
# FIND OUT WHICH COLUMNS HAVE NAs (AND WRITE CODE FOR THEM BELOW)
sapply(scmets, function(x) sum(is.na(x)))

# PERFORM NA ROUGHFIX FUNCTION ON ALL METRICS WITH AT LEAST 1 NA VALUE (ADD CODE AS NEEDED)
scmets$BANKFULLWIDTH <- na.roughfix(scmets$BANKFULLWIDTH) #bankfull width (n = 71 NAs)
scmets$SW_FLUXWS <- na.roughfix(scmets$SW_FLUXWS) #surface water flux (n = 2 NAs)

# MERGE THE DESIRED STREAMCAT METRIC DATA WITH THE TSS AWQMS DATA PULL
tss.sc <- inner_join(tss, scmets, by = "COMID")

# ADD AWQMS COLUMNS (NON-STREAMCAT)
tss.sc.cor <- tss.sc %>% 
  select(-c(MLocID:COMID, L2Eco, L3Eco, Lat_DD, Long_DD, SITE_TYPE, PCT_RESIST))

###*** AT: WONDERING ABOUT A WAY TO AVOID RUNNING COR TABLES A THIRD TIME? I MOVED THE TSS.SC.COR CODE IN THIS SECTION, AFTER TSS.SC WAS MADE
spear2 <- cor(tss.sc.cor, method = "spearman", use = "pairwise.complete.obs")
spear2 <- as.data.frame(spear2)
spear.rows2 <- tibble::rownames_to_column(spear2)

# CONDENSED CORRELATION MATRIX (>0.8 ONLY)
matrix2 <- spear.rows2 %>%  
  gather(-rowname, key = "colname", value = "cor") %>% 
  filter(abs(cor) > 0.8)

# CLEAN UP ENVIRONMENT
rm(list=c('spear.rows2', 'spear2', 'matrix2'))
```

## SUBSET DATA - CALIBRATION, VALIDATION, AND REFERENCE ONLY Subset data

```{r}
# SUBSET DATA AND REMOVE NON-VARIABLE COLUMNS
tss.cal <- tss.sc %>% 
  filter(cal_val == 'CAL') %>%  
  select(-c(MLocID, StationDes, EcoRegion4:COMID))  #subset calibration dataset

tss.val <- tss.sc %>% 
  filter(cal_val == 'VAL') %>%  
  select(-c(MLocID, StationDes, EcoRegion4:COMID))   #subset validation dataset

tss.ref <- tss.sc %>% 
  filter(ReferenceSite == 'REFERENCE') %>%  
  select(-c(MLocID, StationDes, EcoRegion4:COMID))  #subset reference only dataset
```


# **4 - EXPLORE DATA**

## RESPONSE VARIABLE

```{r}
# HISTOGRAM
hist(tss$TSS, main = "", xlab = "TSS") #raw data
hist(log(tss$TSS), main = "", xlab = "log TSS") #log-transformed

# DENSITY PLOT
hist(tss$TSS, main="", prob=T, xlab = "TSS")
d <- density(tss$TSS) #Estimate probability density and save it into **d**
lines(d, col='red',lwd=2) #Superimpose the probability density as a curve on the previous probability density histogram

# BOX PLOT & STRIP CHART
boxplot(tss$TSS, ylab = "TSS")
#stripchart(tss$TSS, vertical = T, pch=1, col='red', add = T)

# NORMALITY ASSUMPTION - GRAPHICALLY 
qqnorm(tss$TSS) #Q-Q plot
qqline(tss$TSS) #not normal

# NORMALITY ASSUMPTION - STATISTICALLY 
shapiro.test(tss$TSS) #Shapiro-Wilk's test - not normal
```

## PREDICTOR VARIABLES

```{r}
# HISTOGRAMS
hist(scmets$WDRW_LDWS, main = "", xlab = "Water Withdrawal")
hist(scmets$ELEVWS, main = "", xlab = "Elevation")
hist(scmets$POPDEN2010WS, main = "", xlab = "Population Density, 2010")
hist(scmets$PCTAGSLPMID2001WS, main = "", xlab = "% Ag 20% slopes (???), 2001")

# KERNEL DENSITY PLOTS
kern <- scmets %>%
  select(CLAYWS, BFIWS, ELEVWS, KFFACTWS, RDDENSWS, STRMPOW_CAT)

kern %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
  facet_wrap(~ key, scales = "free") +
  geom_density() +
  geom_rug() 
```


# **5 - RANDOM FOREST MODELS**

## FULL MODEL - ALL PREDICTORS INCLUDED (N = 83)

#### Build full model

```{r}
set.seed(123)

rf.full <- randomForest(TSS ~ ., tss.cal, importance = TRUE,  mtry = 8, keep.forest = TRUE, ntree = 500) #run random forest model on all predictors
print(rf.full)

varImpPlot(rf.full, type = 1, n.var = 20) #variable importance plot
vip(rf.full, aesthetics = list(color = "blue", fill = "blue")) #another plot

imp <- importance(rf.full)

#not working yet
#reprtree:::plot.reprtree(ReprTree(rf.full, tss.cal, metric='d2'), all = T, depth = 0)

reprtree:::plot.getTree(rf.full, k=1, depth =4)

# How many trees is appropriate?
plot(rf.full, log="x")  # 500 seems to work fine.
```
```{r}
# #std RF
# rf1 = randomForest(TSS ~ ., tss.cal, ntree=500) 
# print(rf1)
# plot(rf1,log="x",main="node depth")

# #limiting tree depth
# for (i in seq(1, 25, 1)) {
# rf2 = randomForest(TSS ~ ., tss.cal, maxnodes=i, ntree=500)
# print(rf2)
# points(rf2$mse,col="darkgreen",type="l")
# print(rf2$mse)
# }

# One way to find best mtry based on tuneRF.
# rf2 <- randomForest(TSS ~ ., tss.cal, ntree=500, importance = TRUE)
#     # Tune mtry based on OOB error
# best_mtry <- tuneRF(tss.cal[, -which(names(tss.cal) == "TSS")], # Predictors
#                         tss.cal$TSS, # Response
#                         ntreeTry = 500, # Number of trees to try for each mtry
#                         stepFactor = 1.5, # Factor to multiply/divide mtry by
#                         improve = 0.01, # Minimum improvement to continue search
#                         trace = TRUE, # Print progress
#                         plot = TRUE) # Plot OOB error vs. mtry
# print(best_mtry)

# Another way to find best mtry based on Caret
# control <- trainControl(method="cv", number=10,returnResamp="all")
# tunegrid <- expand.grid(.mtry=c(3:35))
# caret_res <- train(TSS~., data=tss.cal, method="rf", metric="RMSE", 
#                 tuneGrid=tunegrid, ntree = 500, trControl=control)
# 
# library(ggplot2)
# df =  data.frame(caret_res$resample[,c("mtry","RMSE")],test="caret")
# 
# df = df[df$mtry!=1,]
# 
# ggplot(df,aes(x=mtry,y=RMSE))+
# stat_summary(fun.data=mean_se,geom="errorbar",width=0.2) +
# stat_summary(fun=mean,geom="line")
```


#### Partial dependence plots - full model

```{r}
# PARTIAL DEPENDENCE PLOTS - SINGLE ONLY, NEED TO INCORPORATE FOR LOOP FOR ALL VBLS
partialPlot(rf.full, as.data.frame(tss.cal), STRMPOW_CAT, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), POPDEN2010WS, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), PCTAGSLPMID2001WS, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), WDRW_LDWS, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), PESTIC1997WS, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), ELEVWS, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), SWS, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), PCTCONIF2001WS, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), ROCKNWS, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), RDCRSWS, ylab = "Predicted TSS")
partialPlot(rf.full, as.data.frame(tss.cal), SANDWS, ylab = "Predicted TSS")
# 
# # PARTIAL DEPENDENCE PLOTS - VARIABLES IN ORDER OF DECREASING IMPORTANCE
# # maybe helps with margins too large error
# graphics.off()
# par("mar")
# par(mar=c(1,1,1,1))
# 
# im <- rf.full$importance #importance values for each predictor
# imvar <- rownames(im)[order(im[, 1], decreasing = FALSE)] #predictor's importance values in a decreasing order 
# #par(mfrow=c(4,4)) #make 16 plots per page
# #for (i in seq_along(imvar)) {
# #  partialPlot(rf.full, as.data.frame(tss.cal), imvar[i], xlab = imvar[i], main = "")
# #}
```

#### Model prediction errors - full model

```{r}
# RAW TSS
pred.rf <- predict(rf.full, newdata = tss.cal)
plot(pred.rf ~ tss.cal$TSS, xlab = "Observed TSS", ylab = "Predicted TSS")
abline(a=0,b=1)
(rmse<-sqrt(sum((pred.rf - tss.cal$TSS)^2)/length(tss.cal$TSS)))#prediction error

# LOG-TRANSFORMED TSS **** AT: NOT SURE IF ACCURATE - NEED TO RESEARCH SUITABILITY OF LOG-TRANSFORMING THE RESPONSE IN RF MODELS
pred.rf <- predict(rf.full, newdata = tss.cal)
plot(log(pred.rf) ~ log(tss.cal$TSS), xlab = "log Observed TSS", ylab = "log Predicted TSS")
abline(a=0,b=1)
(rmse<-sqrt(sum((log(pred.rf) - log(tss.cal$TSS))^2)/length(tss.cal$TSS)))#prediction error
```


## REDUCED MODEL - IMPORTANT PREDICTORS ONLY (N = X)

#### Build reduced model

```{r}
set.seed(32)

rf.red <- randomForest(TSS ~ STRMPOW_CAT+ELEVWS+PESTIC1997WS+WDRW_LDWS+POPDEN2010WS+PCTCROP2001WS+SWS, data = tss.cal, importance = TRUE,  keep.forest = TRUE, ntree = 500) 
print(rf.red)

varImpPlot(rf.red, type = 1) #variable importance plot
importance(rf.red)
```

#### Partial dependence plots - reduced model

```{r}
#placeholder
```

#### Model prediction errors - reduced model

```{r}
pred.rf.red <- predict(rf.red, newdata = tss.cal)
plot(pred.rf.red ~ tss.cal$TSS, xlab="Observed TSS", ylab="Predicted TSS", log = "xy")
abline(a=0,b=1)
(rmse<-sqrt(sum((pred.rf.red - tss.cal$TSS)^2)/length(tss.cal$TSS)))#prediction error
```


## SCALE HUMAN-INFLUENCED PREDICTORS TO REFERENCE LEVELS

#### Explore distribution of predictors at reference sites

```{r}
#list of human variables
human <- subset(kitty, kitty$Category == "Anthropogenic")
human <- human %>% select(Metric_Query)

#dataframe for top predictors
top <- tss.sc %>% select(c(POPDEN2010WS,PESTIC1997WS))

#distributions at ref sites
hist(tss.sc$POPDEN2010WS)
hist(tss.ref$POPDEN2010WS)
quantile(tss.ref$POPDEN2010WS, probs = seq(.1, .9, by = .1)) #90th = 4.3163521

#decide on levels to cut each human vbl


#scale back to ref levels
top$POPDEN2010WS <- ifelse(top$POPDEN2010WS >= 4.3163521, 4.31635215, top$POPDEN2010WS)

```







## Run full model with validation data (????????)

```{r}
tss.val$RFtss <- predict(rf.full, tss.val) #model prediction on 'VAL' dataset
RFtss <- tss.val %>% select(RFtss, COMID)
RFval <- tss.val %>% select(TSS, COMID)

# CONFUSION MATRIX
cm <- inner_join(RFtss, RFval, by = "COMID")
confusionMatrix(data = as.factor(cm$RFtss), reference = as.factor(cm$TSS)) #NOT WORKING YET

plot(cm$RFtss, cm$TSS)
```







## REFERENCE ONLY MODEL

#### Build reference only model

```{r}
set.seed(24)

# REFERENCE ONLY
rf.ref <- randomForest(TSS ~ ., data = tss.ref, importance = FALSE,  keep.forest = FALSE, ntree = 500) #run random forest model on all predictors
print(rf.ref)

varImpPlot(rf.ref, type = 1)
importance(rf.ref)
```

#### Run reference only model with test data

```{r}
# TBD

# sample code for creating test data Using caret package
# set.seed(123)  # for reproducibility
# index_2 <- createDataPartition(ames$Sale_Price, p = 0.7, 
#                                list = FALSE)
# train_2 <- ames[index_2, ]
# test_2  <- ames[-index_2, ]
```










## REGRESSION TREES - INFORMATIONAL ONLY AT THIS STAGE

```{r}
# REGRESSION TREES EXPERIMENTATION
# FULL MODEL
rt <- rpart(TSS ~ ., data = tss.cal)
plot(rt)
text(rt, use.n = FALSE)

names(rt)
print(rt)
summary(rt)

# NICER LOOKING TREE
prp(rt, #plot the tree model
    faclen=0,#use full names for factor labels
    extra=1)#display number of obs. for each terminal node
```



#---------------------------------------------------------------------------

THE ADAM L. THOMPSON MEMORIAL CODE BONEYARD

#---------------------------------------------------------------------------

```{r}
# IDENTIFY WHICH COMID(S) DIDN'T YIELD STREAMCAT RESULTS AND INVESTIGATE (FIX IN STATIONS DB BEFORE PROCEEDING)
# kcomids <- meow %>% select(COMID)
# nomatch <- comids[!comids$COMID %in% kcomids$COMID, ] #make data frame showing which COMIDs aren't pulling StreamCat data
# #nomatch.c <- subset(tss, tss$COMID == "23764745" | tss$COMID == "24516234" | tss$COMID == "23815386") #change COMIDs as needed
# rm(list = c('nomatch', 'nomatch.c', 'kcomids')) #clean up environment

# EXPLORE VARIANCE FOR EACH METRIC TO GUIDE WHICH TO KEEP
# meow.sca <- as.data.frame(scale(meow[,-10])) #not used
# 
# var <- meow %>%
#   select(where(is.numeric)) %>%
#   pivot_longer(cols = everything()) %>%
#   group_by(name) %>%
#   summarise(var_value = var(value))
```

```{r}
#tss.r <- tss.sc %>% select(Result_Numeric_mod)
#tss.r <- tss.sc %>% select(Result_Numeric_mod, COMID, cal_val)
r <- randomForest(Result_Numeric_mod ~ CLAYWS + BFIWS + ELEVWS + KFFACTWS + IWI + RDDENSWS, data = tss.sc, na.action = na.exclude)
print(r)

t <- tss.sc[!is.na(tss.sc$BANKFULLWIDTH),]

new_df <- df[!is.na(df)]
  
tss.sc$BANKFULLWIDTH <- na.roughfix(tss.sc$BANKFULLWIDTH) 

missing <- rownames(scmets)[rowSums(is.na(scmets))]
missing <- sum(is.na(scmets))



tss.sc <- left_join(tss, scmets, by = "COMID")
#tss.r <- tss.sc %>% select(Result_Numeric_mod)
r <- randomForest(Result_Numeric_mod ~ CLAYWS + BFIWS + ELEVWS + KFFACTWS + IWI + RDDENSWS, data = tss.sc, na.action = na.exclude)
print(r)
```

#### MULTIPLE LINEAR REGRESSION

```{r}
# LINEAR REGRESSION MODEL FIT
lr.f <- lm(Result_Numeric_mod ~ ., data = tss.cal.test)
#lr.r <- lm(Result_Numeric_mod ~ PCTAGSLPMID2001WS+PCTAGSLPMID2001WS+WETINDEXWS+PRECIP9120WS+CHEMWS+PCTBL2001WS+PCTICE2001WS+
           PCTURBMD2001WS+HYDRLCONDWS+SANDWS+MINEDENSWS+SUPERFUNDDENSWS+RDCRSSLPWTDWS+RDCRSWS+WWTPALLDENSWS, data = tss.cal.test) #subset significant predictors
lr.r2 <- lm(Result_Numeric_mod ~ CONNWS+HYDWS+IWI+PCTSHRB2001WS+PESTIC1997WS+PCTURBMD2001WS+PCTAGSLPMID2001WS+PCTGRS2001WS+PRECIP9120WS+PCTCONIF2001WS, data = tss.cal.test) #subset significant predictors


summary(lr.f)
summary(lr.r)
summary(lr.r2)

par(mfrow=c(2,2))
plot(lr.f)




t <- tss.cal.test %>% select(Result_Numeric_mod,PCTAGSLPMID2001WS,PCTAGSLPMID2001WS,WETINDEXWS,PRECIP9120WS,CHEMWS,PCTBL2001WS,PCTICE2001WS,
           PCTURBMD2001WS,HYDRLCONDWS,SANDWS,MINEDENSWS,SUPERFUNDDENSWS,RDCRSSLPWTDWS,RDCRSWS,WWTPALLDENSWS) #subset significant predictors
#sapply(t, function(x) sum(is.na(x))) #find out which columns have NAs
#source("D:/ESM 566/3_Worksheets/cor.matrix.r")
#cor.matrix(t)
```

```{r}
# EXPLORE IF REMOVED COMIDS WERE OUTLIERS 
removed <- subset(meow2, meow2$COMID == '23774647' | meow2$COMID == '23877125' | meow2$COMID == '23810652')

# MESSING AROUND WITH KERNEL DENSITY PLOTS TO SUMMARIZE METRICS
colnames(scmets)
attach(scmets)

hist(ELEVWS, breaks=100)
hist(BFIWS, breaks=100)
hist(CANALDENSWS, breaks=100)
hist(CLAYWS, breaks=100)
hist(KFFACTWS, breaks=100)

density(CLAYWS)
#-----------
library(KernSmooth)

bkde(CLAYWS)
summary(CLAYWS)

clay.ws<-CLAYWS[!is.na(CLAYWS)]
summary(clay.ws)

plot(bkde(clay.ws))

plot(density(clay.ws))
rug(jitter(clay.ws))
#-----------
kern <- scmets %>%
  select(CLAYWS, BFIWS, ELEVWS, KFFACTWS, IWI, RDDENSWS)

kern %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
  facet_wrap(~ key, scales = "free") +
  geom_density() +
  geom_rug() 
```

```{r}
# RANDOM FORESTS
sapply(scmets, function(x) sum(is.na(x))) #find out which columns have NAs

scmets$BANKFULLWIDTH <- na.roughfix(scmets$BANKFULLWIDTH) #perform na.roughfix on all metrics with at least 1 NA; create extra code rows as needed
scmets$SW_FLUXWS <- na.roughfix(scmets$SW_FLUXWS)

tss.sc <- inner_join(tss, scmets, by = "COMID") #merge TSS AWQMS data pull with desired StreamCat metrics

# SUBSET DATA
tss.cal <- subset(tss.sc, tss.sc$cal_val == "CAL") #subset calibration dataset
tss.val <- subset(tss.sc, tss.sc$cal_val == "VAL") #subset validation dataset
tss.ref <- subset(tss.sc, tss.sc$ReferenceSite == "REFERENCE") #subset reference only dataset

# FULL MODEL
set.seed(42)

rf.full <- randomForest(y = tss.cal$Result_Numeric_mod, x = tss.cal[52:130], importance = FALSE,  keep.forest = FALSE, ntree = 500) #run random forest model on all predictors for 500 trees, calibration dataset
print(rf.full)

varImpPlot(rf.full, type = 1, n.var = 20) #variable importance plot

# REDUCED MODEL
rf.red <- randomForest(Result_Numeric_mod ~ CHEMWS+HYDWS+RDCRSWS+PESTIC1997WS+CONNWS+PCTCROP2001WS+WETINDEXWS+PCTSHRB2001WS+ELEVWS+WDRW_LDWS+IWI, data = tss.cal, importance = FALSE,  keep.forest = FALSE, ntree = 500) #only w/ predictors >4% MSE
print(rf.red)

varImpPlot(rf.red, type = 1) #variable importance plot

importance(rf.red)


# RUN REDUCED MODEL ON VALIDATION DATASET


# REFERENCE ONLY
rf.ref <- randomForest(y = tss.ref$Result_Numeric_mod, x = tss.ref[52:130], importance = FALSE,  keep.forest = FALSE, ntree = 500) #run random forest model on all predictors for 500 trees, calibration dataset
print(rf.ref)

varImpPlot(rf.ref, type = 1)


```

```{r}
#-----------------------------------------------------------------------------------------------
library(vip)# for variable importance plots. you may need to install it first
vip(rt, aesthetics = list(color = "blue", fill = "blue")) #variable importance plot
plotcp(rt) #model cross-validation




# REDUCED MODEL
rt.r <- rpart(Result_Numeric_mod ~ CONNWS+HYDWS+IWI+PCTSHRB2001WS+PESTIC1997WS+PCTURBMD2001WS+PCTAGSLPMID2001WS+PCTGRS2001WS+PRECIP9120WS+PCTCONIF2001WS, data = tss.cal.test)
plot(rt.r)
text(rt.r, use.n = FALSE)

summary(rt.r)

prp(rt.r, #plot the tree model
    faclen=0,#use full names for factor labels
    extra=1)#display number of obs. for each terminal node
#-----------------------------------------------------------------------------------------------
vip(rt.r, aesthetics = list(color = "blue", fill = "blue")) #variable importance plot
plotcp(rt.r) #model cross-validation




# TEST REDUCED MODEL ON VAL DATASET
p <- predict(rt.r, newdata = tss.val) #OLS model prediction
plot(p ~ tss.val$Result_Numeric_mod, ylab = "Predicted TSS", xlab = "Observed TSS", ylim=c(0,30))
abline(a = 0, b = 1) #1:1 line
sqrt(sum((p-tss.val$Result_Numeric_mod)^2)/length(tss.val$Result_Numeric_mod)) #predictive error

# Test if the final reduced model is statistically different from the full model
anova(rt, rt.r) #error  - no applicable method for "rpart"
```

## GROUP PREDICTORS BY HUMAN VS NATURAL DISTURBANCES - WORK IN PROGRESS (SABINE)

```{r}
human.mets <- kitty %>% 
  filter(Category == "Anthropogenic" & kitty$`Use?` == 'y') %>% 
  select(Metric_Query) %>% 
  add_row(Metric_Query = "COMID") # want to include COMID as a column so adding it as a row.

human.mets <- toupper(human.mets$Metric_Query) # All uppercase

natural.mets <- kitty %>% 
  filter(Category == "Natural" & kitty$`Use?` == 'y') %>% 
  select(Metric_Query) %>% 
  add_row(Metric_Query = "COMID")

natural.mets <- toupper(natural.mets$Metric_Query)

# Select out scmets by human and natural.
# Ending in WS only
scmetsws <- scmets %>% 
    select(COMID | ends_with("ws")) %>%  # Keep COMID
    rename_with(~str_remove(., paste0("WS", "$")), ends_with("WS")) # Remove 'WS' suffix so can match to metric names in 'kitty' table

# Subset only column names that are in human or natural mets
scmetws_human <- scmetsws[ , names(scmetsws) %in% human.mets] # 27 variables
scmetws_natural <- scmetsws[ , names(scmetsws) %in% natural.mets] # 48 variables

# Add 'WS' suffix back in
colnames(scmetws_human) <- paste0(colnames(scmetws_human), "WS")
colnames(scmetws_natural) <- paste0(colnames(scmetws_natural), "WS")
  
# Do the same thing for metrics not ending in 'WS'
scmetsnows <- scmets %>% 
    select(!ends_with("ws"))

scmet_human <- scmetsnows[ , names(scmetsnows) %in% human.mets] # 1 variable
scmet_natural <- scmetsnows[ , names(scmetsnows) %in% natural.mets] # 3 variables

sc_human <- cbind(scmetws_human, scmet_human) # 30 variables  #Why is there a column at the end called scmet_human?  SYB figure this out later.
sc_natural <- cbind(scmetws_natural, scmet_natural) # 49 variables (Total of 79, matches scmets)
```


## GROUP PREDICTORS BY HUMAN VS NATURAL DISTURBANCES

```{r}
human.mets <- kitty %>% 
  filter(Category == "Anthropogenic" & kitty$`Use?` == 'y') %>% 
  select(Metric_Query) %>% 
  add_row(Metric_Query = "COMID") # want to include COMID as a column so adding it as a row.

human.mets <- toupper(human.mets$Metric_Query) # All uppercase

# Select out scmets by human only.
  # Ending in WS only
scmetsws <- scmets %>% 
    select(COMID | ends_with("ws")) %>%  # Keep COMID
    rename_with(~str_remove(., paste0("WS", "$")), ends_with("WS")) # Remove 'WS' suffix so can match to metric names in 'kitty' table

  # Subset only column names that are in human or natural mets
scmetws_human <- scmetsws[ , names(scmetsws) %in% human.mets] # 27 variables (including COMID)

  # Add 'WS' suffix back in
colnames(scmetws_human) <- paste0(colnames(scmetws_human), "WS") 
scmetws_human <- scmetws_human %>%  rename(COMID = COMIDWS) # except for COMID
  
  # Do the same thing for metrics not ending in 'WS'
scmetsnows <- scmets %>% 
    select(!ends_with("ws")) %>% 
    select(-c("PCT_EROD", "PCT_RESIST", "STRMPOW_CAT", "NHD_pSLOPE", "SITE_TYPE")) # Ignore the metrics that didn't come from StreamCat.

scmet_human <- scmetsnows[ , names(scmetsnows) %in% human.mets] # 1 variable = COMID. (No other human variables in this group.)

sc_human <- scmetws_human # 28 columns.

# Join with table to get ref status.
sc_human_ref <- sc_human %>% 
  inner_join(tss.sc, sc_human, by='COMID') %>% 
  select(c(COMID:PCTNONAGINTRODMANAGVEGWS.x, ReferenceSite)) %>% 
  filter(ReferenceSite=='REFERENCE') %>% 
  select(-c(COMID, ReferenceSite))

# Tidy up.
rm(list=c('human.mets', 'scmetsws', 'scmetws_human', 'scmetsnows', 'scmet_human', 'sc.human'))
```
