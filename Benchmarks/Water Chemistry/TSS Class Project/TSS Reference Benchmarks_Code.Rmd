---
title: "TSS Reference Benchmarks"
author: "S. Berzins, A. Thompson"
date: "2025-10-21"
output: html_document
---

#### **PREFACE:** This script explores the creation of a site-specific reference benchmark for total suspended solids (TSS) for ESM 566 Fall Environmental Statistics final project.

# **1 - LOAD PACKAGES**

```{r warning=TRUE}
library(tidyverse)
library(StreamCatTools) #why was this removed? Is it needed for pulls?
library(readxl)
library(writexl)
library(randomForest)
library(vip)
library(caret)
library(rpart)
library(rpart.plot)
```

# **2 - IMPORT DATA**

## STATIONS/TSS - *FROM WATER CHEMISTRY BENCHMARKS SCRIPT*

```{r}
tss <- read_excel("tss_2025-11-05.xlsx") #output file from ref benchmarks script

comids <- tss %>% select(COMID) #get just the COMIDs for next step
```

## WATERSHED PREDICTOR VARIABLES - *FROM EPA STREAMCAT*

#### Learn about StreamCat predictors: <https://www.epa.gov/national-aquatic-resource-surveys/streamcat-metrics-and-definitions>

#### View StreamCat updates: <https://www.epa.gov/national-aquatic-resource-surveys/streamcat-updates>

#### Make table of StreamCat metadata and clean up in Excel

```{r}
#supposedly best source for query-able metric names
#partable <- StreamCatTools::sc_get_metric_names()

#name mismatch error message suggests consulting this list
#scpar <- StreamCatTools::sc_get_params(param = 'metric_names') 

#save intermediate file initially; switch to Teams to clean up, then no need to run these first steps
#write_xlsx(partable, path = "C:/Users/athomps/OneDrive - Oregon/Desktop/partable.xlsx") 

kitty <- read_excel("~/BioMonORDEQ/Benchmarks/Water Chemistry/TSS Class Project/StreamCatMetrics_new.xlsx") #final metrics table

#keepers <- subset(kitty, kitty$`Use?`=='y') #keep only parameters of interest
#mets <- keepers[,5] #make data frame of keeper metric names capable of querying data

# FOR TESTING INDIVIDUAL METRICS/COMIDS (e.g., to ensure names match)
#test <- StreamCatTools::sc_get_data(comid = '23910659', metric = 'precipminusevt', showAreaSqKm = FALSE, aoi='watershed')
```

#### Run function to query ALL StreamCat data for selected COMIDs by subcategory

```{r}
# full data pulls use aoi='catchment,watershed,other')) 
# generating Spearman ranks use aoi='watershed')). Run separate line for aoi='other' since they don't pull unless on their own


# FUNCTION - START +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
get_streamcat <- function(comids, type = c("Agriculture","Climate","Dams","Flow","IWI","Land Cover","Lithology","Mining_Toxics","Roads",
                                           "Urban","Wildfire","Others")){
type <- match.arg(type)
#comids_split <- split(comids, ceiling(seq_along(comids)/750)) #removed b/c doesn't seem to be doing anything - wrong data class??

if(type == "Agriculture"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'canaldens,pctagdrainage,pctagslphigh2001,pctagslpmid2001,pestic1997,sw_flux,waterinput,wdrw_LD,pctcrop2001,pcthay2001,cbnf,fert,manure,nani,nsurp,agkffact',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed')) 
  }

if(type == "Climate"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'precip2008,precip8110,precip9120,tmax8110,tmax9120,tmean2008,tmean8110,tmean9120,tmin8110,tmin9120,inorgnwetdep2008,nh42008,no32008,sn2008,precipminusevt,wetindex', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Dams"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'damdens,damnidstor,damnrmstor,NABD_Dens,NABD_NIDStor,NABD_NrmStor', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Flow"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bfi,elev,runoff', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "IWI"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'chem,conn,habt,hyd,sed,temp', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Land Cover"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctbl2001,pctconif2001,pctdecid2001,pctgrs2001,pcthbwet2001,pctice2001,pctmxfst2001,pctow2001,pctshrb2001,pcturbhi2001,pcturblo2001,pcturbmd2001,pcturbop2001,pctwdwet2001,pctfrstloss2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Lithology"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'al2o3,cao,compstrgth,fe2o3,hydrlcond,k2o,mgo,na2o,p2o5,pctalkintruvol,pctalluvcoast,pctcarbresid,pctcoastcrs,pctcolluvsed,pcteolcrs,pcteolfine,pctextruvol,pctglaclakecrs,pctglaclakefine,pctglactilclay,pctglactilcrs,pctglactilloam,pcthydric,pctnoncarbresid,pctsallake,pctsilicic,pctwater,rockn,s,sio2,clay,kffact,om,perm,Rckdep,rckdep,sand,wtdep,n',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Mining_Toxics"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'coalminedens,minedens,superfunddens,tridens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Roads"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'rdcrs,rdcrsslpwtd,rddens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Urban"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'huden2010,npdesdens,popden2010,septic,wwtpalldens,wwtpmajordens,wwtpminordens,pctimp2001,pctimpslphigh2001,pctimpslpmid2001,pctnonagintrodmanagveg', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Wildfire"){ 

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctfire2002,pctburnarea2002,pcthighsev2002,pctincvegresp2002,pctlowsev2002,pctmodsev2002,pctnonprocmask2002,pctundsev2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Others"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bankfulldepth,bankfullwidth,ici,iwi,mast2008,msst2008,mwst2008,thalwagdepth,wettedwidth', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='other')) 
  }

names(streamcat) <- base::toupper(names(streamcat))
return(streamcat)
}
# FUNCTION - END  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```

#### Pull ALL StreamCat data by subcategory and merge

```{r}
# PULL DATA BY SUBCATEGORY/TYPE
ag <- get_streamcat(comids = comids, type = "Agriculture")
clim <- get_streamcat(comids = comids, type = "Climate")
dams <- get_streamcat(comids = comids, type = "Dams")
flow <- get_streamcat(comids = comids, type = "Flow")
iwi <- get_streamcat(comids = comids, type = "IWI") #except prg_bmmi0809 b/c it crashes API
cover <- get_streamcat(comids = comids, type = "Land Cover")
litho <- get_streamcat(comids = comids, type = "Lithology") 
mintox <- get_streamcat(comids = comids, type = "Mining_Toxics")
roads <- get_streamcat(comids = comids, type = "Roads")
urb <- get_streamcat(comids = comids, type = "Urban")
fire <- get_streamcat(comids = comids, type = "Wildfire")
other <- get_streamcat(comids = comids, type = "Others")

# MERGE INTO ONE TABLE
meow <- list(ag, clim, dams, flow, iwi, cover, litho, mintox, roads, urb, fire, other)
meow <- meow %>% reduce(full_join, by='COMID')

# IDENTIFY WHICH COMID(S) DIDN'T YIELD STREAMCAT RESULTS AND INVESTIGATE (FIX IN STATIONS DB BEFORE PROCEEDING)
# kcomids <- meow %>% select(COMID)
# nomatch <- comids[!comids$COMID %in% kcomids$COMID, ] #make data frame showing which COMIDs aren't pulling StreamCat data
# #nomatch.c <- subset(tss, tss$COMID == "23764745" | tss$COMID == "24516234" | tss$COMID == "23815386") #change COMIDs as needed
# rm(list = c('nomatch', 'nomatch.c', 'kcomids')) #clean up environment

# EXPLORE VARIANCE FOR EACH METRIC TO GUIDE WHICH TO KEEP
# meow.sca <- as.data.frame(scale(meow[,-10])) #not used
# 
# var <- meow %>%
#   select(where(is.numeric)) %>%
#   pivot_longer(cols = everything()) %>%
#   group_by(name) %>%
#   summarise(var_value = var(value))
```

#### Make Spearman correlation matrix to identify co-varied parameters

```{r, warning=FALSE}
# FULL CORRELATION MATRIX
spear <- cor(meow, method = "spearman", use = "pairwise.complete.obs")
spear <- as.data.frame(spear)
spear.rows <- tibble::rownames_to_column(spear)

#export once, then clean up in Excel
#write_xlsx(spear.rows, path = "C:/Users/athomps/Oregon/DEQ - Biomonitoring is Fun! - General/Env't Stats Class Project 2025/StreamCat/Spearmans_rerun.xlsx")

# CONDENSED CORRELATION MATRIX (>0.8 ONLY)
matrix <- spear.rows %>%  
  gather(-rowname, key = "colname", value = "cor") %>% 
  filter(abs(cor) > 0.8)

#export once, then clean up in Excel
#write_xlsx(matrix, path = "C:/Users/athomps/Oregon/DEQ - Biomonitoring is Fun! - General/Env't Stats Class Project 2025/StreamCat/Spearmans2_rerun.xlsx")

rm(list=c('ag', 'clim', 'dams', 'flow','iwi', 'cover', 'litho', 'mintox', 'roads', 'urb', 'fire', 'other', 'spear', 'spear.rows'))
```

#### Explore co-varied metrics and select which we want to retain for modeling purposes (SB, SH, AT did together in Excel). See <https://stateoforegon.sharepoint.com/:x:/r/sites/BiomonitoringisFun/Shared%20Documents/General/Env%27t%20Stats%20Class%20Project%202025/StreamCat/Spearmans2.xlsx?d=wc5d82026542a417589be75842d6fafe3&csf=1&web=1&e=dhYR5Q> for decisions, and <https://stateoforegon.sharepoint.com/:x:/r/sites/BiomonitoringisFun/Shared%20Documents/General/Env%27t%20Stats%20Class%20Project%202025/StreamCat/Spearmans2.xlsx?d=wc5d82026542a417589be75842d6fafe3&csf=1&web=1&e=dhYR5Q> for full list of metric names.

#### Run StreamCat function again, but only for parameters of interest

```{r}
# FUNCTION - START +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
get_streamcat <- function(comids, type = c("Agriculture2","Climate2","Dams2","Flow2","IWI2","Land Cover2","Lithology2","Mining_Toxics2","Roads2",
                                           "Urban2","Wildfire2","Others2")){
type <- match.arg(type)
#comids_split <- split(comids, ceiling(seq_along(comids)/750)) #removed b/c doesn't seem to be doing anything - wrong data class??

if(type == "Agriculture2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'canaldens,pctagdrainage,pctagslpmid2001,pestic1997,wdrw_LD,pctcrop2001,sw_flux',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed')) 
  }

if(type == "Climate2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'precip9120,wetindex', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Dams2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'damdens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Flow2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bfi,elev',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "IWI2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'chem,conn,hyd',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Land Cover2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctbl2001,pctconif2001,pctgrs2001,pcthbwet2001,pctice2001,pctmxfst2001,pctow2001,pctshrb2001,pcturbhi2001,pcturbmd2001,pcturbop2001,pctwdwet2001,pctfrstloss2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Lithology2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'compstrgth,fe2o3,hydrlcond,na2o,pctalkintruvol,pctalluvcoast,pctcarbresid,pctcoastcrs,pctcolluvsed,pcteolcrs,pcteolfine,pctextruvol,pctglaclakecrs,pctglaclakefine,pctglactilclay,pctglactilcrs,pctglactilloam,pcthydric,pctnoncarbresid,pctsallake,pctsilicic,pctwater,rockn,s,clay,kffact,om,Rckdep,rckdep,sand,wtdep,n',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Mining_Toxics2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'coalminedens,minedens,superfunddens,tridens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Roads2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'rdcrs,rdcrsslpwtd,rddens', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Urban2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'npdesdens,popden2010,septic,wwtpalldens,wwtpmajordens,pctimp2001,pctnonagintrodmanagveg', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }

if(type == "Wildfire2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'pctfire2002,pctincvegresp2002,pctnonprocmask2002', 
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='watershed'))
  }
# Removed iwi from Others 2 to remove IWI metrics from data pull.
if(type == "Others2"){

  streamcat <- purrr::map_dfr(comids, ~StreamCatTools::sc_get_data(.,
                                                                           metric = 'bankfullwidth,msst2008',
                                                                           showAreaSqKm = FALSE,
                                                                           aoi='other')) 
  }

names(streamcat) <- base::toupper(names(streamcat))
return(streamcat)
}
# FUNCTION - END  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```

#### Pull and merge StreamCat data for parameters of interest

```{r}
# PULL DATA BY SUBCATEGORY/TYPE
ag2 <- get_streamcat(comids = comids, type = "Agriculture2")
clim2 <- get_streamcat(comids = comids, type = "Climate2")
dams2 <- get_streamcat(comids = comids, type = "Dams2")
flow2 <- get_streamcat(comids = comids, type = "Flow2")
#iwi2 <- get_streamcat(comids = comids, type = "IWI2") #except prg_bmmi0809 b/c it crashes API
cover2 <- get_streamcat(comids = comids, type = "Land Cover2")
litho2 <- get_streamcat(comids = comids, type = "Lithology2") 
mintox2 <- get_streamcat(comids = comids, type = "Mining_Toxics2")
roads2 <- get_streamcat(comids = comids, type = "Roads2")
urb2 <- get_streamcat(comids = comids, type = "Urban2")
fire2 <- get_streamcat(comids = comids, type = "Wildfire2")
other2 <- get_streamcat(comids = comids, type = "Others2")

# MERGE STREAMCAT DATA PULL
meow2 <- list(ag2, clim2, dams2, flow2, cover2, litho2, mintox2, roads2, urb2, fire2, other2) # Removed iwi2 to remove IWI metrics.  11/5/25.
meow2 <- meow2 %>% reduce(full_join, by='COMID')

# REMOVE METRICS FOR UNWANTED REPRESENTATIVE COMIDS FOR SITES ON HIGH RES NHD LAYER
scmets <- subset(meow2, meow2$COMID != '23774647' & meow2$COMID != '23877125' & meow2$COMID != '23810652')
```

#### Pefrorm final correlation check

```{r, warning=FALSE}
# FULL CORRELATION MATRIX
spear2 <- cor(meow2, method = "spearman", use = "pairwise.complete.obs")
spear2 <- as.data.frame(spear2)
spear.rows2 <- tibble::rownames_to_column(spear2)

# CONDENSED CORRELATION MATRIX (>0.8 ONLY)
matrix2 <- spear.rows2 %>%  
  gather(-rowname, key = "colname", value = "cor") %>% 
  filter(abs(cor) > 0.8)

# CONTINUE ONCE NO CORRELATED VARIABLES REMAIN
```

# **3 - PREPARE DATA FOR MODELS**

## HANDLE NA VALUES AND MERGE PREDICTORS WITH TSS DATA 

```{r}
# FIND OUT WHICH COLUMNS HAVE NAs (AND WRITE CODE FOR THEM BELOW)
sapply(scmets, function(x) sum(is.na(x)))

# PERFORM NA ROUGHFIX FUNCTION ON ALL METRICS WITH AT LEAST 1 NA VALUE (ADD CODE AS NEEDED)
scmets$BANKFULLWIDTH <- na.roughfix(scmets$BANKFULLWIDTH) #bankfull width (n = 71 NAs)
scmets$SW_FLUXWS <- na.roughfix(scmets$SW_FLUXWS) #surface water flux (n = 2 NAs)

# MERGE THE DESIRED STREAMCAT METRIC DATA WITH THE TSS AWQMS DATA PULL
tss.sc <- inner_join(tss, scmets, by = "COMID")

# CLEAN UP ENVIRONMENT
rm(list=c('ag2','clim2','cover2','dams2','fire2','flow2','litho2','mintox2','other2','roads2','urb2','meow2', 'spear.rows2', 'spear2', 'matrix2'))
```

## GROUP PREDICTORS BY HUMAN VS NATURAL DISTURBANCES - WORK IN PROGRESS (SABINE)

```{r}
human.mets <- kitty %>% 
  filter(Category == "Anthropogenic" & kitty$`Use?` == 'y') %>% 
  select(Metric_Query) %>% 
  add_row(Metric_Query = "COMID") # want to include COMID as a column so adding it as a row.

human.mets <- toupper(human.mets$Metric_Query) # All uppercase

natural.mets <- kitty %>% 
  filter(Category == "Natural" & kitty$`Use?` == 'y') %>% 
  select(Metric_Query) %>% 
  add_row(Metric_Query = "COMID")

natural.mets <- toupper(natural.mets$Metric_Query)

# Select out scmets by human and natural.
# Ending in WS only
scmetsws <- scmets %>% 
    select(COMID | ends_with("ws")) %>%  # Keep COMID
    rename_with(~str_remove(., paste0("WS", "$")), ends_with("WS")) # Remove 'WS' suffix so can match to metric names in 'kitty' table

# Subset only column names that are in human or natural mets
scmetws_human <- scmetsws[ , names(scmetsws) %in% human.mets] # 27 variables
scmetws_natural <- scmetsws[ , names(scmetsws) %in% natural.mets] # 48 variables

# Add 'WS' suffix back in
colnames(scmetws_human) <- paste0(colnames(scmetws_human), "WS")
colnames(scmetws_natural) <- paste0(colnames(scmetws_natural), "WS")
  
# Do the same thing for metrics not ending in 'WS'
scmetsnows <- scmets %>% 
    select(!ends_with("ws"))

scmet_human <- scmetsnows[ , names(scmetsnows) %in% human.mets] # 1 variable
scmet_natural <- scmetsnows[ , names(scmetsnows) %in% natural.mets] # 3 variables

sc_human <- cbind(scmetws_human, scmet_human) # 30 variables  #Why is there a column at the end called scmet_human?  SYB figure this out later.
sc_natural <- cbind(scmetws_natural, scmet_natural) # 49 variables (Total of 79, matches scmets)
```

## SUBSET DATA - CALIBRATION, VALIDATION, AND REFERENCE ONLY Subset data

```{r}
# SUBSET DATA AND REMOVE NON-VARIABLE ROWS
tss.cal <- tss.sc %>% 
  filter(cal_val == 'CAL') %>%  
  select(-c(MLocID:COMID))  #subset calibration dataset

tss.val <- tss.sc %>% 
  filter(cal_val == 'VAL') %>%  
  select(-c(MLocID:COMID))  #subset validation dataset

tss.ref <- tss.sc %>% 
  filter(ReferenceSite == 'REFERENCE') %>%  
  select(-c(MLocID:COMID)) #subset reference only dataset
```

# **4 - EXPLORE DATA**

## RESPONSE VARIABLE

```{r}
# HISTOGRAM
hist(tss$TSS, main = "", xlab = "TSS")

# DENSITY PLOT
hist(tss$TSS, main="", prob=T, xlab="TSS")
d <- density(tss$TSS) #Estimate probability density and save it into **d**
lines(d, col='red',lwd=2) #Superimpose the probability density as a curve on the previous probability density histogram

# BOX PLOT & STRIP CHART
boxplot(tss$TSS, ylab = "TSS")
stripchart(tss$TSS, vertical = T, pch=1, col='red', add = T)

# NORMALITY ASSUMPTION - GRAPHICALLY 
qqnorm(tss$TSS) #Q-Q plot
qqline(tss$TSS) #not normal

# NORMALITY ASSUMPTION - STATISTICALLY 
shapiro.test(tss$TSS) #Shapiro-Wilk's test - not normal
```

## PREDICTOR VARIABLES

```{r}
# HISTOGRAMS
hist(scmets$WDRW_LDWS, main = "", xlab = "Water Withdrawal")
hist(scmets$ELEVWS, main = "", xlab = "Elevation")
hist(scmets$POPDEN2010WS, main = "", xlab = "Population Density, 2010")
hist(scmets$PCTAGSLPMID2001WS, main = "", xlab = "% Ag 20% slopes (???), 2001")
```


# **5 - BUILD MODELS**

## RANDOM FORESTS

#### Full model - all predictors included (n = 79??)

```{r}
# FULL MODEL
set.seed(42)

rf.full <- randomForest(TSS ~ ., tss.cal, importance = TRUE,  keep.forest = TRUE, ntree = 500) #run random forest model on all predictors
print(rf.full)

varImpPlot(rf.full, type = 1, n.var = 20) #variable importance plot
vip(rf.full, aesthetics = list(color = "blue", fill = "blue")) #another plot

importance(rf.full)

# PARTIAL DEPENDENCE PLOTS - SINGLE ONLY, NEED TO INCORPORATE FOR LOOP FOR ALL VBLS
partialPlot(rf.full, as.data.frame(tss.cal), ELEVWS, ylab = "Predicted TSS")

# PARTIAL DEPENDENCE PLOTS - VARIABLES IN ORDER OF DECREASING IMPORTANCE
# AVOIDS MARGINS TOO SMALL ERROR
graphics.off()
par("mar")
par(mar=c(1,1,1,1))

im <- rf.full$importance #importance values for each predictor
imvar <- rownames(im)[order(im[, 1], decreasing = TRUE)] #predictor's importance values in a decreasing order 
par(mfrow=c(4,4)) #make 16 plots per page
for (i in seq_along(imvar)) {
  partialPlot(rf.full, as.data.frame(tss.cal), imvar[i], xlab = imvar[i], main = "")
}

# MODEL'S PREDICTION ERROR
pred.rf <- predict(rf.full, newdata = tss.cal)
plot(pred.rf ~ tss.cal$TSS, xlab="Observed TSS", ylab="Predicted TSS")
abline(a=0,b=1)
(rmse<-sqrt(sum((pred.rf - tss.cal$TSS)^2)/length(tss.cal$TSS)))#prediction error
```

#### Reduced model - only important predictors included (n = 12)

```{r}
# REDUCED MODEL
set.seed(42)

rf.red <- randomForest(TSS ~ POPDEN2010WS + PCTAGSLPMID2001WS + WDRW_LDWS + PESTIC1997WS + ELEVWS + SWS + 
          PCTCONIF2001WS + ROCKNWS + RDCRSWS + SANDWS + CLAYWS, data = tss.cal, importance = TRUE,  keep.forest = TRUE, ntree = 500) 
print(rf.red)

varImpPlot(rf.red, type = 1) #variable importance plot
importance(rf.red)

# MODEL'S PREDICTION ERROR
pred.rf.red <- predict(rf.red, newdata = tss.cal)
plot(pred.rf.red ~ tss.cal$TSS, xlab="Observed TSS", ylab="Predicted TSS")
abline(a=0,b=1)
(rmse<-sqrt(sum((pred.rf.red - tss.cal$TSS)^2)/length(tss.cal$TSS)))#prediction error
```

#### Test full model with validation data

```{r}
# CONFUSION MATRIX
tss.val$RFtss <- predict(rf.full, tss.val) #model prediction on 'VAL' dataset
RFtss <- tss.val %>% select(RFtss, COMID)
RFval <- tss.val %>% select(TSS, COMID)

cm <- inner_join(RFtss, RFval, by = "COMID")
confusionMatrix(data = as.factor(cm$RFtss), reference = as.factor(cm$TSS)) #NOT WORKING YET

plot(cm$RFtss, cm$TSS)
```

## REFERENCE ONLY MODEL

```{r}
# REFERENCE ONLY
rf.ref <- randomForest(TSS ~ ., data = tss.ref, importance = TRUE,  keep.forest = TRUE, ntree = 500) #run random forest model on all predictors
print(rf.ref)

varImpPlot(rf.ref, type = 1)
importance(rf.ref)
```

## REGRESSION TREES

```{r}
# REGRESSION TREES EXPERIMENTATION
# FULL MODEL
rt <- rpart(TSS ~ ., data = tss.cal)
plot(rt)
text(rt, use.n = TRUE)

names(rt)
print(rt)
summary(rt)

# NICER LOOKING TREE
prp(rt, #plot the tree model
    faclen=0,#use full names for factor labels
    extra=1)#display number of obs. for each terminal node
```



#---------------------------------------------------------------------------

THE ADAM L. THOMPSON MEMORIAL CODE BONEYARD

#---------------------------------------------------------------------------

```{r}
#tss.r <- tss.sc %>% select(Result_Numeric_mod)
#tss.r <- tss.sc %>% select(Result_Numeric_mod, COMID, cal_val)
r <- randomForest(Result_Numeric_mod ~ CLAYWS + BFIWS + ELEVWS + KFFACTWS + IWI + RDDENSWS, data = tss.sc, na.action = na.exclude)
print(r)

t <- tss.sc[!is.na(tss.sc$BANKFULLWIDTH),]

new_df <- df[!is.na(df)]
  
tss.sc$BANKFULLWIDTH <- na.roughfix(tss.sc$BANKFULLWIDTH) 

missing <- rownames(scmets)[rowSums(is.na(scmets))]
missing <- sum(is.na(scmets))



tss.sc <- left_join(tss, scmets, by = "COMID")
#tss.r <- tss.sc %>% select(Result_Numeric_mod)
r <- randomForest(Result_Numeric_mod ~ CLAYWS + BFIWS + ELEVWS + KFFACTWS + IWI + RDDENSWS, data = tss.sc, na.action = na.exclude)
print(r)
```

#### MULTIPLE LINEAR REGRESSION

```{r}
# LINEAR REGRESSION MODEL FIT
lr.f <- lm(Result_Numeric_mod ~ ., data = tss.cal.test)
#lr.r <- lm(Result_Numeric_mod ~ PCTAGSLPMID2001WS+PCTAGSLPMID2001WS+WETINDEXWS+PRECIP9120WS+CHEMWS+PCTBL2001WS+PCTICE2001WS+
           PCTURBMD2001WS+HYDRLCONDWS+SANDWS+MINEDENSWS+SUPERFUNDDENSWS+RDCRSSLPWTDWS+RDCRSWS+WWTPALLDENSWS, data = tss.cal.test) #subset significant predictors
lr.r2 <- lm(Result_Numeric_mod ~ CONNWS+HYDWS+IWI+PCTSHRB2001WS+PESTIC1997WS+PCTURBMD2001WS+PCTAGSLPMID2001WS+PCTGRS2001WS+PRECIP9120WS+PCTCONIF2001WS, data = tss.cal.test) #subset significant predictors


summary(lr.f)
summary(lr.r)
summary(lr.r2)

par(mfrow=c(2,2))
plot(lr.f)




t <- tss.cal.test %>% select(Result_Numeric_mod,PCTAGSLPMID2001WS,PCTAGSLPMID2001WS,WETINDEXWS,PRECIP9120WS,CHEMWS,PCTBL2001WS,PCTICE2001WS,
           PCTURBMD2001WS,HYDRLCONDWS,SANDWS,MINEDENSWS,SUPERFUNDDENSWS,RDCRSSLPWTDWS,RDCRSWS,WWTPALLDENSWS) #subset significant predictors
#sapply(t, function(x) sum(is.na(x))) #find out which columns have NAs
#source("D:/ESM 566/3_Worksheets/cor.matrix.r")
#cor.matrix(t)
```

```{r}
# EXPLORE IF REMOVED COMIDS WERE OUTLIERS 
removed <- subset(meow2, meow2$COMID == '23774647' | meow2$COMID == '23877125' | meow2$COMID == '23810652')

# MESSING AROUND WITH KERNEL DENSITY PLOTS TO SUMMARIZE METRICS
colnames(scmets)
attach(scmets)

hist(ELEVWS, breaks=100)
hist(BFIWS, breaks=100)
hist(CANALDENSWS, breaks=100)
hist(CLAYWS, breaks=100)
hist(KFFACTWS, breaks=100)

density(CLAYWS)
#-----------
library(KernSmooth)

bkde(CLAYWS)
summary(CLAYWS)

clay.ws<-CLAYWS[!is.na(CLAYWS)]
summary(clay.ws)

plot(bkde(clay.ws))

plot(density(clay.ws))
rug(jitter(clay.ws))
#-----------
kern <- scmets %>%
  select(CLAYWS, BFIWS, ELEVWS, KFFACTWS, IWI, RDDENSWS)

kern %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
  facet_wrap(~ key, scales = "free") +
  geom_density() +
  geom_rug() 
```

```{r}
# RANDOM FORESTS
sapply(scmets, function(x) sum(is.na(x))) #find out which columns have NAs

scmets$BANKFULLWIDTH <- na.roughfix(scmets$BANKFULLWIDTH) #perform na.roughfix on all metrics with at least 1 NA; create extra code rows as needed
scmets$SW_FLUXWS <- na.roughfix(scmets$SW_FLUXWS)

tss.sc <- inner_join(tss, scmets, by = "COMID") #merge TSS AWQMS data pull with desired StreamCat metrics

# SUBSET DATA
tss.cal <- subset(tss.sc, tss.sc$cal_val == "CAL") #subset calibration dataset
tss.val <- subset(tss.sc, tss.sc$cal_val == "VAL") #subset validation dataset
tss.ref <- subset(tss.sc, tss.sc$ReferenceSite == "REFERENCE") #subset reference only dataset

# FULL MODEL
set.seed(42)

rf.full <- randomForest(y = tss.cal$Result_Numeric_mod, x = tss.cal[52:130], importance = TRUE,  keep.forest = TRUE, ntree = 500) #run random forest model on all predictors for 500 trees, calibration dataset
print(rf.full)

varImpPlot(rf.full, type = 1, n.var = 20) #variable importance plot

# REDUCED MODEL
rf.red <- randomForest(Result_Numeric_mod ~ CHEMWS+HYDWS+RDCRSWS+PESTIC1997WS+CONNWS+PCTCROP2001WS+WETINDEXWS+PCTSHRB2001WS+ELEVWS+WDRW_LDWS+IWI, data = tss.cal, importance = TRUE,  keep.forest = TRUE, ntree = 500) #only w/ predictors >4% MSE
print(rf.red)

varImpPlot(rf.red, type = 1) #variable importance plot

importance(rf.red)


# RUN REDUCED MODEL ON VALIDATION DATASET


# REFERENCE ONLY
rf.ref <- randomForest(y = tss.ref$Result_Numeric_mod, x = tss.ref[52:130], importance = TRUE,  keep.forest = TRUE, ntree = 500) #run random forest model on all predictors for 500 trees, calibration dataset
print(rf.ref)

varImpPlot(rf.ref, type = 1)


```

```{r}
#-----------------------------------------------------------------------------------------------
library(vip)# for variable importance plots. you may need to install it first
vip(rt, aesthetics = list(color = "blue", fill = "blue")) #variable importance plot
plotcp(rt) #model cross-validation




# REDUCED MODEL
rt.r <- rpart(Result_Numeric_mod ~ CONNWS+HYDWS+IWI+PCTSHRB2001WS+PESTIC1997WS+PCTURBMD2001WS+PCTAGSLPMID2001WS+PCTGRS2001WS+PRECIP9120WS+PCTCONIF2001WS, data = tss.cal.test)
plot(rt.r)
text(rt.r, use.n = TRUE)

summary(rt.r)

prp(rt.r, #plot the tree model
    faclen=0,#use full names for factor labels
    extra=1)#display number of obs. for each terminal node
#-----------------------------------------------------------------------------------------------
vip(rt.r, aesthetics = list(color = "blue", fill = "blue")) #variable importance plot
plotcp(rt.r) #model cross-validation




# TEST REDUCED MODEL ON VAL DATASET
p <- predict(rt.r, newdata = tss.val) #OLS model prediction
plot(p ~ tss.val$Result_Numeric_mod, ylab = "Predicted TSS", xlab = "Observed TSS", ylim=c(0,30))
abline(a = 0, b = 1) #1:1 line
sqrt(sum((p-tss.val$Result_Numeric_mod)^2)/length(tss.val$Result_Numeric_mod)) #predictive error

# Test if the final reduced model is statistically different from the full model
anova(rt, rt.r) #error  - no applicable method for "rpart"
```
